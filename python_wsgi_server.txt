
************************************************************************
tornado gunicorn uwsgi + gevent 的抗并发原理其实一样的 都是用协程实现并发 
************************************************************************

gunicorn/uwsgi可以类比nginx的作用(属于同级的概念:web server),起一个web server的作用,(就是wsgi外面套个web server)
它们里面调用flask/django写的app,框架需要提供一个wsgi.py文件/其实就是一个wsgi规范接口函数(它就是框架的入口函数):
    def app(environ, start_response):
            data = b"Hello, World!\n"
            start_response("200 OK", [
                ("Content-Type", "text/plain"),
                ("Content-Length", str(len(data)))
            ])
            return iter([data])
            
则当多个请求到来时,首先由gunicorn/uwsgi/可以类比nginx这样的web server 来处理`多个请求`的任务(server处理了多请求并发相关的功能!!)
而每一个请求内部的具体处理则调用app去处理,

tornado框架特殊的在于它自带了一个httpserver,而且性能也很好.所以tornado官方推荐部署tornado的时候使用:
    ngnix + 4个httpserver进程 + tornado app (就类似于ngnix + uwsgi/gunicorn+ flask/django app)
使用nginx处理静态资源请求,而动态请求则转发给tornado的httpserver + tornado app来处理. 
只是tornado自己写的httpserver和自己的tornado框架通信时不一定要遵循wsgi接口,但tornado也提供了wsgi文件,用来和非自己httpserver的其他web server协作.
(wsgi是专门用于在不同的web server和不同的框架通信的规范接口),若想使用uwsgi/gunicorn + tornado app则需要使用tornado的wsgi文件.
而且tornado框架里提供了回调/协程的方式来实现异步非阻塞/并发功能等,尽量做到使每一个请求在处理时都尽可能地最快完成 !!

==================================================================================================================================
撇开httpserver层面的东西,当在一个请求内部的处理时,若也需要异步操作/并发操作则需要使用tornado/gevent/twisted这样的框架,
目的就是使这一个请求的处理时间尽量能够最快的完成.
所以：
    多个请求是由web server并发处理的(异步非阻塞/协程)+一个请求内部的阻塞代码等也可以使用某些库来并发/异步处理而最快完成=高性能的 web server + app 
---------------------------------------------------------------------------------------------------------------------------------- 
以上说法有点混淆...理解的不完全对:
  多个请求是靠web server来实现并发处理的,而在每个请求内部处理时遇到IO阻塞时,需要能够挂起当前函数/协程,以让server不阻塞等待立即去处理后面的请求,
  无论是采用gunicorn/uwsgi+gevent还是tornado方案,都是需要web server调度器 + 每一个请求内部能够异步非阻塞的 = 高性能的web server + app 
==================================================================================================================================

之所以有时候已经使用了uwsgi/gunicorn做wsgi server后还要再加个nginx是因为nginx在处理静态资源方面很优秀(/static的请求直接用nginx处理)
所以可以把请求分为2部分:
    请求静态资源的请求就直接靠nginx处理 + 动态的请求则由ngnix再转发给uwsgi/gunicorn去处理：
        #例1: nginx配置动态请求转发给uwsgi处理(使用uwsgi协议转发):
        location / {
            include uwsgi_params;
            uwsgi_pass 127.0.0.1:3000;
        }
        #例2: nginx配置动态请求转发给gunicorn处理(直接转发请求):
        server {
            listen 80;
            server_name example.org; # 这是HOST机器的外部域名，用地址也行

            location / {
                proxy_pass http://127.0.0.1:8000; # 这里是指向 gunicorn host 的服务地址
                proxy_set_header Host $host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            }
          }
          
==================================================================================================================================
抛出一个web server(apache/ngnix/uwsgi/gunicorn/httpserver)如何处理C10K大访问量请求问题:
    现在有10000个请求同时访问你的web server,每一个请求里面有句访问数据库的函数(大约10s能完成)阻塞住了 ????
    
如果是tornado的httpserver,则在每一个请求里的数据库访问那一句处都有一句 yield async_request_db(),
则当前请求会挂起(cpu不会阻塞等待在此处),tornado去并发处理其他请求了,最终10000个请求几乎只花10s即可全部处理完成！所以tornado的并发性能很高！

*********************************************************************************************************************
---------------------------------------------------------------------------------------------------------------------
从这里也可以发现了另一个问题所在: 
尽管从web server层面已经实现了可以高并发处理多个请求了,但在每一个请求的处理逻辑里面,如果它有数据库访问/网络请求之类的代码,它还是会阻塞,
而且必须阻塞等待!!因为每一个请求里面的代码逻辑是需要依赖该网络请求拿到的结果之后,才能继续往下走逻辑的!! 所以它必须阻塞等待结果...
所以:
"优化数据库性能" ==> 提高每一个请求的处理速度,才是web项目的性能优化的关键工作啊..

 多个连接进来               server并发处理多个连接           开始每一个连接的处理-->
     |                          |                             |      
(客户端连接(底层socket) -> web server处理请求(底层socket) -> wsgi入口函数 -> web框架 -> 你的app业务逻辑处理代码 -> 把响应原路返回...)
所以开发一个项目选用什么web框架(django/flask都可以)其实都可以!! 因为当你懂了以后就知道:不同的web框架其实本质上都是个wsgi入口函数而已...
能否高并发处理多请求其实是在部署时选用什么web server(nginx/apache等)决定的,是否能高并发的能力与web框架无关,与web server有关...
而在一个项目的开发工作中,如何优化数据库的访问性能,提高每一个请求的处理速度,才是所谓"性能优化"的关键啊....
---------------------------------------------------------------------------------------------------------------------
*********************************************************************************************************************

apache是多线程方式处理,nginx也是tornado一样的异步非阻塞并发处理(nginx是怎么知道当前请求IO阻塞了呢并且切换cpu去处理其他请求?怎么实现的??),
那么uwsgi/gunicorn又是怎么处理并发请求的呢??它们又怎么和gevent搭配来处理并发请求的??

其实问题就是: 
web server同时处理多个请求,而每个请求里都有一句IO阻塞的代码(假设访问mysql需要10s返回),如何做到同时处理了这么多请求??都有异步非阻塞处理??

答案是：
gunicorn/uwsgi web server跑的时候默认采用sync阻塞模式,这种模式下10000个请求就是靠多进程/多线程来处理的,就是同步阻塞,根本也没什么抗并发能力可言！
所以:必须要gunicorn/uwsgi + gevent组合,搭配gevent使用,指定使用gevent worker模式来跑(注意:gevent要求你的代码里一定要使用python socket的库！)
gunicorn/uwsgi worker在gevent async模式下,其实就相当于是个gevent的协程调度器,就像自己使用gevent时的pool.map(handle_request, requests):
10000个请求并发进来后,每个请求都被包在了一个gevent的greenlet(协程)里,当在一个请求里IO阻塞时,gevent会立即挂起当前协程/切换cpu去处理下一个请求,
这样多个请求就可以并发处理了(gunicorn/uwsgi + gevent就和tornado httpserver的原理一样了:协程实现并发！都是异步非阻塞).

可以参考gunicorn的GeventWorker源码,看看它怎么写的,概括一句就是import gevent_pool; gevent_pool.map(handle_request, requests) ！！哈哈哈哈
gunicorn是python写的,uwsgi是c写的,但都支持gevent worker模式跑.
==================================================================================================================================


**************************************************************************************************************************************
tornado好处是一致性,整个开发都是使用tornado自己的一套东西,缺点也是必须使用tornado框架来写...

而gunicorn/uwsgi + gevent的优点是: 
    不限定框架,你可以使用任何django/flask等框架来写,只要保证一点: 代码里http调用部分使用的库其底层一定要走的是python socket(可以被gevent patch)
    不能是c的socket(gevent不能monkey_patch它,c的socket不能与libev的loop通信,无法调度)
    
根据项目的具体情况选择使用不同的框架和部署方式吧,都可以达到异步非阻塞的高性能/抗并发效果...
**************************************************************************************************************************************

